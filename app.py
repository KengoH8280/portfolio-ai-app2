# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15uf8UEXl5GCBoa1ZYvK1-jqLsUCwvttc
"""

# ============================================
# ★ 完全版：分類(3M先) + トレンド特徴 + Hybrid配分
#    + 欠損/上場日対応バックテスト + SPY/QQQ/VT比較（Colab）★
# ============================================

# 0) ライブラリ
#!pip -q install yfinance PyPortfolioOpt numpy pandas scikit-learn lightgbm

# 1) Imports & 設定
import warnings, numpy as np, pandas as pd, matplotlib.pyplot as plt, yfinance as yf
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.ensemble import RandomForestClassifier

warnings.filterwarnings("ignore")
plt.rcParams["figure.figsize"] = (10,5)

# ====== 設定（必要ならここだけ調整） ======
# ユニバース：レバETFもOK（例：TQQQ, UPRO, TMF）
TICKERS = [
    "SPY","QQQ","IWM","EFA","EEM","VNQ","GLD","DBC","UUP","IEF","LQD","TLT",
    "TQQQ","UPRO","TMF"  # ←レバETF
]
START   = "2010-01-01"
FEE     = 0.001             # 片道 0.10%
TOP_N   = 6                 # 予測上位N
MAX_W   = 0.30              # MVOの通常ETFの1銘柄上限
LOOKBACK_MONTHS = 36        # 学習開始に必要な履歴（月）
TARGET_VOL_A = 0.18         # Hybridの目標年率ボラ（攻め：0.16〜0.20）
REBALANCE = "quarterly"     # "monthly" or "quarterly"
METHOD    = "hybrid"        # "topn" / "mvo" / "hybrid"
SAVE_CSV  = True

# 分類勝率 p を“月次期待超過リターン”に換算（MVO/年率化用）
PROB_TO_RET_SCALE = 0.04     # 0.02〜0.06 で調整。攻めるなら大きめ

# レバETFは上限を低めに
LEVERAGED_KEYS = ["TQQQ","UPRO","SPXL","SPXS","QLD","TMF","TBT","TNA","TZA"]
LEV_MAX_W = 0.15

# LightGBM（無ければRFに自動フォールバック）
try:
    import lightgbm as lgb
    HAS_LGBM = True
except Exception:
    HAS_LGBM = False

# 2) データ取得（個別DL・MultiIndex完全対応）
def fetch_close_per_ticker(ticker: str, start: str):
    df = yf.download(ticker, start=start, auto_adjust=True, progress=False, group_by=False)
    if df is None or len(df)==0: return None
    if isinstance(df, pd.Series):
        s = df.copy(); s.name = ticker; return s
    if isinstance(df.columns, pd.MultiIndex):
        last = df.columns.get_level_values(-1); last_lower = last.astype(str).str.lower()
        for cand in ("close","adj close","price","last"):
            hits = last[last_lower==cand]
            if len(hits)>0:
                sub = df.xs(hits[0], axis=1, level=-1)
                s = sub.iloc[:,0] if isinstance(sub, pd.DataFrame) else sub
                s = s.copy(); s.name = ticker; return s
        sub = df.xs(last.unique()[0], axis=1, level=-1)
        s = sub.iloc[:,0] if isinstance(sub, pd.DataFrame) else sub
        s = s.copy(); s.name = ticker; return s
    cols_lower = pd.Index(df.columns.astype(str)).str.lower()
    for cand in ("close","adj close","price","last"):
        if cand in set(cols_lower):
            col = df.columns[cols_lower.get_loc(cand)]
            s = df[col].copy(); s.name = ticker; return s
    if df.shape[1]==1:
        s = df.iloc[:,0].copy(); s.name = ticker; return s
    return None

series_list, missing = [], []
for tk in TICKERS:
    s = fetch_close_per_ticker(tk, START)
    if s is None or s.dropna().empty: missing.append(tk)
    else: series_list.append(s)
if missing:
    raise RuntimeError(f"価格を取得できなかった銘柄: {missing}")

prices   = pd.concat(series_list, axis=1).sort_index().ffill().dropna(how="all")
m_prices = prices.resample("M").last().dropna(how="all")
m_rets   = m_prices.pct_change().dropna(how="all")

# 3) 特徴量（トレンド強化）
def build_features_trend(m_rets: pd.DataFrame, m_prices: pd.DataFrame) -> pd.DataFrame:
    mr = m_rets.astype("float32").replace([np.inf,-np.inf], np.nan).copy()
    feats = {}
    # リターン系
    feats["ret_1m"]  = mr
    feats["ret_3m"]  = mr.rolling(3).sum()
    feats["ret_6m"]  = mr.rolling(6).sum()
    feats["ret_12m"] = mr.rolling(12).sum()
    # モメンタム（12-1）
    feats["mom_12_1"] = (1+mr).rolling(12).apply(np.prod, raw=True) - 1 - mr
    # ボラ
    feats["vol_3m"]  = mr.rolling(3).std()
    feats["vol_6m"]  = mr.rolling(6).std()
    feats["vol_12m"] = mr.rolling(12).std()
    # 移動平均乖離
    for win in [12,24,36]:
        sma = m_prices.rolling(win).mean()
        feats[f"sma{win}_gap"] = (m_prices/sma - 1).reindex(mr.index)
    # 高値/安値からの距離（12M）
    roll_max = m_prices.rolling(12).max()
    roll_min = m_prices.rolling(12).min()
    feats["dist_high12"] = (m_prices/roll_max - 1).reindex(mr.index)
    feats["dist_low12"]  = (m_prices/roll_min - 1).reindex(mr.index)
    # 12M累積リターンZスコア
    cumret12 = (1+mr).rolling(12).apply(np.prod, raw=True) - 1
    feats["ret12_z"] = cumret12.apply(lambda row: (row - row.mean())/row.std(), axis=1)

    wide = []
    for name, mat in feats.items():
        w = mat.copy(); w.columns = pd.MultiIndex.from_product([w.columns,[name]])
        wide.append(w)
    full = pd.concat(wide, axis=1).dropna(how="all").stack(0).sort_index()
    return full

X_full = build_features_trend(m_rets, m_prices)

# 4) ターゲット（分類：次の3か月で上がるか？）
future3 = (1 + m_rets).shift(-1).rolling(3).apply(np.prod, raw=True) - 1
y_wide  = (future3 > 0).astype(int)
y       = y_wide.stack().rename("target_cls")
data = X_full.join(y, how="inner").dropna(subset=["target_cls"])
features = X_full.columns

# 5) ウォークフォワード学習（分類：LGBM or RF）
def train_one_period(X_train, y_train):
    imp = SimpleImputer(strategy="median")
    Xtr = imp.fit_transform(X_train)
    scaler = StandardScaler()
    Xtr = scaler.fit_transform(Xtr)
    if HAS_LGBM:
        model = lgb.LGBMClassifier(
            n_estimators=700, learning_rate=0.03, num_leaves=31,
            subsample=0.8, colsample_bytree=0.8, reg_lambda=1.0,
            min_child_samples=15, random_state=42
        )
    else:
        model = RandomForestClassifier(n_estimators=700, min_samples_leaf=3,
                                       n_jobs=-1, random_state=42)
    model.fit(Xtr, y_train)
    return model, imp, scaler

def predict_one_period(model, imp, scaler, X_test):
    Xte = scaler.transform(imp.transform(X_test))
    if hasattr(model, "predict_proba"):
        p = model.predict_proba(Xte)[:,1]  # 上昇確率
    else:
        p = model.predict(Xte).astype(float)
    return pd.Series(p, index=X_test.index)

months = sorted(set(idx[0] for idx in data.index))
pred_store = {}  # {month: Series(ticker -> prob_up)}

for i, m in enumerate(months):
    train_months = months[:i]
    if len(train_months) < LOOKBACK_MONTHS: continue
    Xtr = data.loc[(train_months, slice(None)), features]
    ytr = data.loc[(train_months, slice(None)), "target_cls"]
    model, imp, scaler = train_one_period(Xtr, ytr)
    Xte = data.loc[(m, slice(None)), features]
    preds = predict_one_period(model, imp, scaler, Xte)
    if isinstance(preds.index, pd.MultiIndex): preds = preds.unstack().iloc[0]
    pred_store[m] = preds

assert len(pred_store)>0, "予測が作れませんでした（データ不足の可能性）"

# 6) 配分ロジック（TopN/MVO/Hybrid）
from pypfopt.risk_models import CovarianceShrinkage
from pypfopt.efficient_frontier import EfficientFrontier
from pypfopt.objective_functions import L2_reg

def is_leveraged(tk):
    return any(k in tk for k in LEVERAGED_KEYS)

def compute_weights_for_month(month_ts, method="hybrid", top_n=TOP_N, max_w=MAX_W,
                              m_prices=None, pred_store=None, tickers=None):
    assert month_ts in pred_store
    p = pred_store[month_ts].reindex(tickers).astype(float)      # 勝率(0..1)
    score = (p - 0.5).clip(lower=0)                              # 正の自信だけ採用

    # MVO用の“疑似月次期待リターン”
    mu_m = PROB_TO_RET_SCALE * (p - 0.5)                         # -~+数%/月
    mu_a = (1 + mu_m).clip(lower=0.5)**12 - 1                    # 年率（下限で安定化）

    # ティッカーごとの上限制約（レバETFだけ低め）
    bounds = []
    for tk in tickers:
        ub = min(max_w, LEV_MAX_W) if is_leveraged(tk) else max_w
        bounds.append((0.0, ub))

    method = method.lower()
    if method == "topn":
        picks = score.sort_values(ascending=False).index[:top_n]
        sel = score.loc[picks]
        w = (sel/sel.sum()) if sel.sum()>0 else pd.Series(1/top_n, index=picks)
        w = w.reindex(tickers).fillna(0.0)

    elif method == "mvo":
        mlist = list(m_prices.index); i = mlist.index(month_ts); win = min(36, i) if i>0 else 1
        S = CovarianceShrinkage(m_prices.iloc[i-win:i]).ledoit_wolf()
        try:
            ef = EfficientFrontier(mu_a.to_dict(), S, weight_bounds=bounds)
            ef.add_objective(L2_reg, gamma=0.001)
            wd = ef.max_sharpe()
            w = pd.Series([wd.get(tk,0.0) for tk in tickers], index=tickers)
            w = w/w.sum() if w.sum()>0 else pd.Series(1/len(tickers), index=tickers)
        except Exception:
            picks = score.sort_values(ascending=False).index[:top_n]
            w = pd.Series(0.0, index=tickers); w.loc[picks] = 1.0/top_n

    elif method == "hybrid":
        # 攻め：Top-N 期待値比例
        picks = score.sort_values(ascending=False).index[:top_n]
        sel = score.loc[picks]
        alpha_w = (sel/sel.sum()) if sel.sum()>0 else pd.Series(1/top_n, index=picks)
        alpha_w = alpha_w.reindex(tickers).fillna(0.0)

        # レジーム：SPY 200SMA（無ければ常にRisk-On）
        if "SPY" in tickers and "SPY" in m_prices.columns:
            spy = m_prices["SPY"]; sma200 = spy.rolling(200, min_periods=200).mean()
            risk_on = True if pd.isna(sma200.loc[month_ts]) else (spy.loc[month_ts] >= sma200.loc[month_ts])
        else:
            risk_on = True

        # 守り：債券/金プール（広め）
        defensive_keys = ["IEF","LQD","TLT","BND","AGG","SHY","BIL","SGOV","GLD","TMF"]
        pool = [t for t in tickers if any(k in t for k in defensive_keys)]
        pool = pool if len(pool)>0 else tickers
        def_scores = score.loc[pool]
        def_w = (def_scores/def_scores.sum()) if def_scores.sum()>0 else pd.Series(1/len(pool), index=pool)
        def_w = def_w.reindex(tickers).fillna(0.0)

        # レジームでブレンド（Risk-Onで攻め90%）
        blend = 0.9 if risk_on else 0.2
        sleeve = (blend*alpha_w + (1-blend)*def_w)
        sleeve = sleeve/sleeve.sum()

        # ボラ・ターゲティング（年率 TARGET_VOL_A、レバ無し）
        mlist = list(m_prices.index); i = mlist.index(month_ts); win = min(6, i) if i>0 else 1
        rets6 = m_prices.iloc[i-win:i].pct_change().dropna()
        if len(rets6)>1:
            cov = rets6.cov().values; wv = sleeve.values
            vol_m = np.sqrt(np.dot(wv, cov @ wv)); vol_a = vol_m*np.sqrt(12)
            scale = min(1.0, TARGET_VOL_A/(vol_a+1e-9))
        else:
            scale = 1.0
        w = scale*sleeve; w = w/w.sum()
    else:
        raise ValueError("unknown method")

    return pd.DataFrame({"Forecast_m": mu_m, "Forecast_a": (1+mu_m)**12 - 1, "Weight": w})

def make_allocation_table(pred_store, m_prices, method=METHOD, top_n=TOP_N, max_w=MAX_W):
    tickers = list(m_prices.columns); rows = []
    for m in sorted(pred_store.keys()):
        df = compute_weights_for_month(m, method=method, top_n=top_n, max_w=max_w,
                                       m_prices=m_prices, pred_store=pred_store, tickers=tickers)
        df = df.reset_index().rename(columns={"index":"Ticker"})
        df["Method"] = method.upper()
        df["Month"]  = pd.to_datetime(m)
        rows.append(df)
    alloc = pd.concat(rows, axis=0, ignore_index=True)
    alloc["Month"] = pd.to_datetime(alloc["Month"]).dt.to_period("M").dt.to_timestamp("M")
    return alloc[["Method","Month","Ticker","Forecast_m","Forecast_a","Weight"]].sort_values(
        ["Month","Method","Weight"], ascending=[True,True,False]
    )

alloc_table = make_allocation_table(pred_store, m_prices, method=METHOD, top_n=TOP_N, max_w=MAX_W)

# 7) 欠損/上場日対応のバックテスト（NaN耐性）
# === 修正版：欠損/上場日対応のバックテスト（shape不一致バグFix版） ===
def backtest_from_alloc_table(m_prices, alloc_table, fee=0.001, rebalance="monthly"):
    months  = list(m_prices.index)
    tickers = list(m_prices.columns)
    alloc   = alloc_table.copy()
    alloc["Month"] = pd.to_datetime(alloc["Month"]).dt.to_period("M").dt.to_timestamp("M")

    nav = pd.Series(index=months, dtype=float); nav.iloc[0] = 1.0

    alive0 = m_prices.iloc[0].notna().values
    w = np.where(alive0, 1.0, 0.0); w = w/w.sum() if w.sum()>0 else np.zeros_like(w)
    current_w = w

    for i in range(1, len(months)):
        t, prev = months[i], months[i-1]
        alive = m_prices.iloc[i].notna().values & m_prices.iloc[i-1].notna().values

        # リバランス（四半期 or 毎月）
        do_reb = (rebalance=="monthly") or (t.month in (3,6,9,12))
        if do_reb:
            row = alloc.loc[alloc["Month"] == t]
            if not row.empty:
                w_new = row.set_index("Ticker")["Weight"].reindex(tickers).fillna(0).values
                w_new = np.where(alive, w_new, 0.0)
                if w_new.sum() > 0:
                    prev_eff = np.where(alive, current_w, 0.0)
                    prev_eff = prev_eff/prev_eff.sum() if prev_eff.sum()>0 else prev_eff
                    turnover = np.abs(w_new/w_new.sum() - prev_eff).sum()/2
                    nav.iloc[i-1] *= (1 - fee*turnover)
                    current_w = w_new / w_new.sum()

        # 月次リターン（生存銘柄だけ、同次元で計算）
        ret_vec = (m_prices.iloc[i]/m_prices.iloc[i-1] - 1.0).values
        valid = np.isfinite(ret_vec) & alive
        if valid.any():
            w_eff   = np.where(valid, current_w, 0.0)
            w_eff   = w_eff / w_eff.sum() if w_eff.sum()>0 else np.zeros_like(w_eff)
            ret_eff = np.where(valid, ret_vec, 0.0)   # ← 長さを縮めない
            r = float(np.dot(w_eff, ret_eff))
        else:
            r = 0.0
        nav.iloc[i] = nav.iloc[i-1]*(1 + r)

    return nav


model_nav = backtest_from_alloc_table(m_prices, alloc_table, fee=FEE, rebalance=REBALANCE)

# 8) ベンチマーク（SPY/QQQ/VT）買い持ち
bench_tickers = ["SPY","QQQ","VT"]
bench_series = {}
for bt in bench_tickers:
    try:
        s = fetch_close_per_ticker(bt, START)
        if s is not None:
            m = s.resample("M").last().dropna()
            bench_series[bt] = (1 + m.pct_change().fillna(0)).cumprod()
    except Exception:
        pass

# 9) グラフ & メトリクス
def cagr(nav, freq=12): years=len(nav)/freq; return (nav.iloc[-1]/nav.iloc[0])**(1/years)-1
def max_dd(nav): peak=nav.cummax(); return (nav/peak-1).min()
def sharpe(nav, rf_annual=0.0):
    r=nav.pct_change().dropna(); mu,sd=r.mean(), r.std()
    return (((1+mu)**12-1)-rf_annual)/(sd*np.sqrt(12)) if sd>0 else np.nan

print("=== Performance ===")
for name, nav in bench_series.items():
    print(f"{name:3s} | CAGR: {cagr(nav):.2%} | MaxDD: {max_dd(nav):.2%} | Sharpe: {sharpe(nav):.2f}")
print(f"Model({METHOD}, {REBALANCE}) | CAGR: {cagr(model_nav):.2%} | MaxDD: {max_dd(model_nav):.2%} | Sharpe: {sharpe(model_nav):.2f}")

plt.figure(figsize=(10,5))
for name, nav in bench_series.items():
    plt.plot(nav.index, nav/nav.iloc[0], label=f"{name} (Buy&Hold)")
plt.plot(model_nav.index, model_nav/model_nav.iloc[0], label=f"Model ({METHOD}, {REBALANCE.capitalize()} RB)")
plt.title("SPY / QQQ / VT vs Model NAV"); plt.ylabel("Normalized NAV")
plt.grid(True); plt.legend(); plt.show()

# 10) 直近月の配分 & CSV
last_m = sorted(pred_store.keys())[-1]
latest = compute_weights_for_month(last_m, method=METHOD, top_n=TOP_N, max_w=MAX_W,
                                   m_prices=m_prices, pred_store=pred_store, tickers=list(m_prices.columns))
print("Latest month:", last_m.strftime("%Y-%m"))
display(latest.sort_values("Weight", ascending=False))

if SAVE_CSV:
    alloc_table.to_csv("allocations_table.csv", index=False)
    pd.DataFrame({"date":model_nav.index, "nav":model_nav.values}).to_csv("model_nav.csv", index=False)
    for name, nav in bench_series.items():
        pd.DataFrame({"date":nav.index, "nav":nav.values}).to_csv(f"{name.lower()}_nav.csv", index=False)
    print("Saved: allocations_table.csv, model_nav.csv, (spy/qqq/vt)_nav.csv")

# ============================================================
# 最新の次月ポートフォリオ + 総合レポート（ベンチ比較・リスク指標）
# ＊完成版コードの一番最後にこのセルを追加／置き換え
# ============================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from pandas.tseries.offsets import MonthEnd

# ---------- 0) ユーティリティ ----------
def cagr(nav, freq=12):
    years = len(nav)/freq
    return (nav.iloc[-1]/nav.iloc[0])**(1/years) - 1

def max_dd(nav):
    peak = nav.cummax()
    dd = nav/peak - 1.0
    return float(dd.min())

def sharpe(nav, rf_annual=0.0):
    r = nav.pct_change().dropna()
    mu, sd = r.mean(), r.std()
    return ((((1+mu)**12 - 1) - rf_annual)/(sd*np.sqrt(12))) if sd>0 else np.nan

def sortino(nav, rf_annual=0.0):
    r = nav.pct_change().dropna()
    dr = r[r < 0]
    dd = dr.std()
    if dd == 0: return np.nan
    ex_annual = (1+r.mean())**12 - 1 - rf_annual
    return float(ex_annual/(dd*np.sqrt(12)))

def ann_vol(nav):
    r = nav.pct_change().dropna()
    return float(r.std()*np.sqrt(12))

def calmar(nav):
    dd = max_dd(nav)
    return np.nan if dd == 0 else cagr(nav)/abs(dd)

# ---------- 1) 「最新の次月」用の配分（直近月末の予測→翌月に適用） ----------
# pred_store は「その月末の情報で作った予測」を格納している想定
last_m = sorted(pred_store.keys())[-1]                     # 直近の予測月（＝直近月末）
apply_month = (pd.Timestamp(last_m) + MonthEnd(1))         # 実運用ではその翌月に適用
tickers = list(m_prices.columns)

latest_df = compute_weights_for_month(
    last_m, method=METHOD, top_n=TOP_N, max_w=MAX_W,
    m_prices=m_prices, pred_store=pred_store, tickers=tickers
).reindex(tickers)

print(f"=== 次月ポートフォリオ（{last_m.strftime('%Y-%m')} 月末で作成 → {apply_month.strftime('%Y-%m')} に適用想定 / {METHOD.upper()}）===\n")
display(latest_df.sort_values("Weight", ascending=False).style.format(
    {"Forecast_m":"{:.4f}", "Forecast_a":"{:.2%}", "Weight":"{:.2%}"}
))

# 図示（水平バー）
plt.figure(figsize=(8,5))
latest_df["Weight"].sort_values().plot(kind="barh")
plt.title(f"Next-Month Weights — built at {last_m.strftime('%Y-%m')}-end / apply {apply_month.strftime('%Y-%m')}")
plt.xlabel("Weight")
plt.grid(True, axis="x")
plt.tight_layout()
plt.show()

# CSV保存（任意）
latest_df.reset_index().rename(columns={"index":"Ticker"}).to_csv(
    f"portfolio_next_{apply_month.strftime('%Y-%m')}.csv", index=False
)
print(f"Saved: portfolio_next_{apply_month.strftime('%Y-%m')}.csv")

# ---------- 2) 総合レポート（モデル・ベンチ比較・リスク指標） ----------
model_ret_m = model_nav.pct_change().dropna()

# ベンチ（あるものだけ使う）
benches = {}
if "SPY" in m_prices.columns:
    benches["SPY"] = (1 + m_prices["SPY"].pct_change().fillna(0)).cumprod()
if "QQQ" in m_prices.columns:
    benches["QQQ"] = (1 + m_prices["QQQ"].pct_change().fillna(0)).cumprod()
if "VT" in m_prices.columns:
    benches["VT"]  = (1 + m_prices["VT"].pct_change().fillna(0)).cumprod()

# 勝率・ベンチ勝率
hit_ratio = (model_ret_m > 0).mean()
beat_rates = {}
irates = {}
for name, bnav in benches.items():
    bret = bnav.pct_change().dropna()
    df_cmp = pd.concat([model_ret_m, bret], axis=1, join="inner")
    df_cmp.columns = ["model","bench"]
    beat_rates[name] = (df_cmp["model"] > df_cmp["bench"]).mean()
    # 情報比（IR）
    diff = df_cmp["model"] - df_cmp["bench"]
    irates[name] = diff.mean()/diff.std()*np.sqrt(12) if diff.std()>0 else np.nan

# ターンオーバー（リバランス月のみ概算）
wide_w = (alloc_table.pivot_table(index="Month", columns="Ticker", values="Weight", aggfunc="last")
          .sort_index())
if REBALANCE.lower().startswith("q"):
    reb_months = [m for m in wide_w.index if pd.Timestamp(m).month in (3,6,9,12)]
else:
    reb_months = list(wide_w.index)
wide_rb = wide_w.loc[reb_months].fillna(0.0)
turnovers = (wide_rb.diff().abs().sum(axis=1)*0.5).dropna()
avg_turnover = float(turnovers.mean()) if len(turnovers)>0 else np.nan

# 追加の健全性チェック
r = model_ret_m
best_m  = float(r.max()) if len(r) else np.nan
worst_m = float(r.min()) if len(r) else np.nan
skew    = float(r.skew()) if len(r) else np.nan
kurt    = float(r.kurt()) if len(r) else np.nan

# レポート出力
print("\n=== Model Report ===")
print(f"Period                 : {model_nav.index[0].strftime('%Y-%m')} → {model_nav.index[-1].strftime('%Y-%m')}")
print(f"CAGR                   : {cagr(model_nav):.2%}")
print(f"Max Drawdown           : {max_dd(model_nav):.2%}")
print(f"Sharpe Ratio           : {sharpe(model_nav):.2f}")
print(f"Sortino Ratio          : {sortino(model_nav):.2f}")
print(f"Annual Volatility      : {ann_vol(model_nav):.2%}")
print(f"Calmar Ratio           : {calmar(model_nav):.2f}")
print(f"Hit Ratio (monthly)    : {hit_ratio:.1%}")
print(f"Avg Turnover / RB      : {avg_turnover:.2%}")
if benches:
    for name in benches:
        print(f"Beat {name} (monthly)  : {beat_rates[name]:.1%}   |   Information Ratio vs {name}: {irates[name]:.2f}")
print(f"Best Month             : {best_m:.2%}")
print(f"Worst Month            : {worst_m:.2%}")
print(f"Skew / Kurtosis        : {skew:.2f} / {kurt:.2f}")

# 参考：ベンチCAGR併記
for name, bnav in benches.items():
    print(f"{name} CAGR              : {cagr(bnav):.2%}")

# ---------- 3) “アクティブ銘柄だけ” もう一枚 ----------
top_only = latest_df[latest_df["Weight"]>0]
if not top_only.empty:
    plt.figure(figsize=(8,4))
    plt.bar(top_only.index, top_only["Weight"].values)
    plt.title(f"Active Positions — apply {apply_month.strftime('%Y-%m')} (Weight>0)")
    plt.ylabel("Weight")
    plt.xticks(rotation=45, ha="right")
    plt.grid(True, axis="y")
    plt.tight_layout()
    plt.show()

# =========================================================
# 追加セル：リアルタイム1か月先 予測 & 来月用ポートフォリオ生成
# （完成版の一番下に貼って実行）
# =========================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# 1) 1か月先ターゲット（分類）で直近モデルを再学習 → 今月末時点の特徴で来月の上昇確率を出す
def build_rt_dataset_1m(m_rets, X_full):
    # 1か月先の方向性（翌月のリターン > 0 ?）
    future1 = m_rets.shift(-1)
    y1_wide = (future1 > 0).astype(int)
    y1 = y1_wide.stack().rename("target_cls_1m")
    data1 = X_full.join(y1, how="inner").dropna(subset=["target_cls_1m"])
    feats = X_full.columns
    return data1, feats

def train_cls(X_train, y_train):
    # 完成版で使っている学習器を流用（LGBM or RF）
    imp = SimpleImputer(strategy="median")
    Xtr = imp.fit_transform(X_train)
    scaler = StandardScaler()
    Xtr = scaler.fit_transform(Xtr)
    if HAS_LGBM:
        model = lgb.LGBMClassifier(
            n_estimators=600, learning_rate=0.03, num_leaves=31,
            subsample=0.8, colsample_bytree=0.8, reg_lambda=1.0,
            min_child_samples=15, random_state=42
        )
    else:
        model = RandomForestClassifier(n_estimators=600, min_samples_leaf=3,
                                       n_jobs=-1, random_state=42)
    model.fit(Xtr, y_train)
    return model, imp, scaler

def predict_proba(model, imp, scaler, X_test):
    Xte = scaler.transform(imp.transform(X_test))
    if hasattr(model, "predict_proba"):
        return pd.Series(model.predict_proba(Xte)[:,1], index=X_test.index)  # 上昇確率
    else:
        return pd.Series(model.predict(Xte).astype(float), index=X_test.index)

# データ組み立て
data1, feats1 = build_rt_dataset_1m(m_rets, X_full)
months_all = sorted(set(idx[0] for idx in data1.index))
if len(months_all) < LOOKBACK_MONTHS + 1:
    raise RuntimeError("学習に十分な月数がありません（LOOKBACK_MONTHS を小さくしてください）")

# 直近“予測したい月”＝featuresが存在する最後の月
t_pred = months_all[-1]  # 例：2025-08（その月末の情報で、翌月＝9月を予測）
train_months = months_all[:-1]  # 直近月を除いた全履歴で学習
train_months = train_months[-max(LOOKBACK_MONTHS, 24):]  # 念のため上限/下限

Xtr = data1.loc[(train_months, slice(None)), feats1]
ytr = data1.loc[(train_months, slice(None)), "target_cls_1m"]
model1m, imp1m, scaler1m = train_cls(Xtr, ytr)

Xte = data1.loc[(t_pred, slice(None)), feats1]
proba_up_1m = predict_proba(model1m, imp1m, scaler1m, Xte)
if isinstance(proba_up_1m.index, pd.MultiIndex):
    proba_up_1m = proba_up_1m.unstack().iloc[0]
proba_up_1m = proba_up_1m.reindex(m_prices.columns).astype(float)

# 2) 来月の推奨配分（Top-N比例 または 既存Hybridロジックに流用）

# --- Top-N 期待値比例（シンプル） ---
top_n = TOP_N
score = (proba_up_1m - 0.5).clip(lower=0)  # 正の自信のみ
picks = score.sort_values(ascending=False).index[:top_n]
sel = score.loc[picks]
w_topn_next = (sel/sel.sum()) if sel.sum()>0 else pd.Series(1/top_n, index=picks)
w_topn_next = w_topn_next.reindex(m_prices.columns).fillna(0.0)

# --- Hybridロジックで来月用ウェイトを作る（完成版と整合） ---
def weights_next_month_hybrid(t_month):
    # compute_weights_for_month は pred_store を参照する設計なので、
    # 一時的に「t_month → proba_up_1m」を注入して流用します
    tmp_pred_store = {t_month: proba_up_1m.copy()}
    dfw = compute_weights_for_month(t_month, method=METHOD, top_n=TOP_N, max_w=MAX_W,
                                    m_prices=m_prices, pred_store=tmp_pred_store,
                                    tickers=list(m_prices.columns))
    return dfw["Weight"]

w_hybrid_next = weights_next_month_hybrid(t_pred)

# 3) 表示：来月の推奨（t_pred の翌月に適用される想定）
print(f"\n=== 1か月先 予測（{t_pred.strftime('%Y-%m')}の月末時点で作成 → 翌月適用想定）===\n")
out_tbl = pd.DataFrame({
    "ProbUp_1m": proba_up_1m,
    "Score": score,
    "Weight_TopN": w_topn_next,
    "Weight_Hybrid": w_hybrid_next
}).fillna(0).sort_values("Weight_Hybrid", ascending=False)
display(out_tbl.style.format({"ProbUp_1m":"{:.2%}","Score":"{:.3f}",
                              "Weight_TopN":"{:.2%}","Weight_Hybrid":"{:.2%}"}))

# 4) 図示（Hybrid推奨）
plt.figure(figsize=(8,5))
out_tbl["Weight_Hybrid"].sort_values().plot(kind="barh")
plt.title(f"Next-Month Portfolio (Hybrid) — built at {t_pred.strftime('%Y-%m')}-end")
plt.xlabel("Weight")
plt.grid(True, axis="x")
plt.tight_layout()
plt.show()

# 5) 備考を出力
print("\n【使い方のメモ】")
print("・この配分は “t_pred 月末” のデータで作った来月向けの推奨です。")
print("・日次で運用したい場合は、月中に再実行して最新月を t_pred として再計算してください。")
print("・TopNは単純で攻め、Hybridはレジーム&ボラ調整込みで安定寄りです。")

#%%writefile requirements.txt
#streamlit
#pandas
#matplotlib
#scikit-learn
#lightgbm
#yfinance